本日は、Rail課題４の実装を行いLGTMをいただいた。
課題は、「著者、タグ、コンテンツ（記事内容）に関しても検索が行えるようにしてください。」
というものである。

著者、タグの検索機能は簡単に実装できたが、記事内容の実装に手こずった。
理由は、中間テーブルの存在である。

初めに、scopeをこのように実装していた
scope :body_contain, ->(body_word) { where('body LIKE ?', "#{body_word}%") }

これだとbodyがnilとなる。

デバックをすると、このようになる。
```
[1] pry(main)> article = Article.first
  Article Load (0.3ms)  SELECT `articles`.* FROM `articles` ORDER BY `articles`.`id` ASC LIMIT 1
=> #<Article:0x0000ffffae63c6e0
 id: 1,
 category_id: 2,
 author_id: 3,
 uuid: "bfa6ebc5-0dd0-4bf7-b713-2a9c2b18fe79",
 slug: "test",
 title: "テスト",
 description: "テスト記事",
 body: "<div class=\"media-image\"></div>",
 state: "publish_wait",
 published_at: Sat, 27 Sep 2025 10:15:00.000000000 JST +09:00,
 created_at: Tue, 23 Sep 2025 11:35:00.000000000 JST +09:00,
 updated_at: Sun, 28 Sep 2025 10:18:34.000000000 JST +09:00,
 deleted_at: nil>
[2] pry(main)> article.body
=> "<div class=\"media-image\"></div>"
[3] pry(main)> article.sentences
=>   Sentence Load (1.4ms)  SELECT `sentences`.* FROM `sentences` INNER JOIN `article_blocks` ON `sentences`.`id` = `article_blocks`.`blockable_id` WHERE `article_blocks`.`article_id` = 1 AND `article_blocks`.`blockable_type` = 'Sentence' ORDER BY `article_blocks`.`level` ASC
[]
```
つまり、articleとsentencesをjoinしなくてはならない。
scopeはこのようになる。
```
scope :body_contain, ->(body) { joins(:sentences).merge(where('sentences.body LIKE ?', "%#{body}%")) }
```

ちなみにtagも中間テーブルがあるので、このようにする。
```
scope :by_tag, ->(tag_id) { joins(:tags).where( tags: { id: tag_id }) }
```

```
{ joins(:sentences).merge(where('sentences.body LIKE ?', "%#{body}%")) }
```
このようにsentences.bodyと明示する理由は、articleテーブルにもbodyカラムが存在するからである。

カリキュラム外では、ポリモーフィック関連について調査した。
まだ腹落ちしていないので、ここには記載しないことにする。
１１月のアウトプット会で発表できるくらいには理解したい。
明日は、課題６に取り組む。