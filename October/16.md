本日は、ActiveRecord演習の課題が完了した。
whereメソッドの記述方法は、２つある。
パターン１：ハッシュ形式
```
.where(film（テーブル名）: { length: 100}) #film.length = 100
```
パターン２：文字列形式
```
.where("film.length >= ?", 100) #film.length >= 100
```
比較演算子を使用する場合、文字列形式が適している。
？はプレースホルダーといい、SQLインジェクション攻撃を防止するため、必要である。

GROUP BY 後のHAVINGは、GROUP BYで指定したカラムでしか、条件を絞り込めない。

このようなクエリがあったとする
```
MySQL [sakila_rails_development]> SELECT film.film_id,film.title,SUM(payment.amount)AS revenue
    -> FROM film
    -> JOIN film_actor
    -> ON film_actor.film_id = film.film_id
    -> JOIN actor
    -> ON actor.actor_id = film_actor.actor_id
    -> JOIN inventory
    -> ON inventory.film_id = film.film_id
    -> JOIN rental
    -> ON rental.inventory_id = inventory.inventory_id
    -> JOIN payment
    -> ON payment.rental_id = rental.rental_id
    -> GROUP BY film.film_id,film.title
    -> HAVING actor.first_name = "JOE" AND last_name = "SWANK"
    -> ORDER BY revenue DESC
    -> LIMIT 10;
ERROR 1054 (42S22): Unknown column 'actor.first_name' in 'having clause'
```
エラーの内容を視覚的にすると
GROUP BY前
```
film_id | title     | actor.first_name
865     | SUNRISE   | JOE
865     | SUNRISE   | MARY    (もし複数俳優がいたら)
```

GROUP BY後
```
film_id | title     | actor.first_name
865     | SUNRISE   | ??? (どちらを選ぶ？)
```
また、SELECT句の非集計カラムは、すべてGROUP BYに含める必要がある。
集計関数は、基本的にGROUP BYとセットである。


また、テーブル名の記述であるが、joinsはアソシエーション名を使用し、selectは実際のテーブル名を使用する

joins:　アソシエーション名を使用
```
joins(:actors)  # ← アソシエーション名
joins(inventories: { rentals: :payments })  # ← ネストしたアソシエーション名
```

select:　実際のテーブル名を使用
```
select("film.film_id, film.title, SUM(payment.amount)")
#       ↑film テーブル    ↑payment テーブル（paymentsではない）
```

joinsの役割：
ActiveRecordがSQL生成するためのヒント
関連の定義を参照してJOINを構築

selectの役割：
生のSQL文字列として扱われる
データベースに直接渡される

また、本日は、Ruby応用に着手した。
久しぶりにアルゴリズムをするので、思っていた通り、手が動かない。（SQLとActiveRecord着手時と同じように）
Ruby応用は、Rubyチェリー本と並行して進めることとする。（なので少し時間がかかる。目標は１週間）