昨日は、遅くまでカリキュラムをしていたので、Today I Learnedを記すことができなかった。
昨日は、Rails応用課題９と、課題１０を終わらせた。
課題９は、バックエンド側の実装はできたが、フロント側の実装ができず、ギブアップをした。
JavaScriptとCSSのキャッチアップが必要だが、今はカリキュラムを進めることを優先する。
アプリを開発する段階で、色々と試しながらキャッチアップしていくことにする。
課題９は、大きく分けて３つの実装がある。
１つ目は、faviconとog_imageを個別に削除する実装。
２つ目は、main_imagesの複数アップロード機能、削除機能の実装
３つ目は、swiperによるsliderの実装。
着手するにあたり、何から実装するのか考えると、まず、画像がアップロードされなければ、sliderは出来ないと考えた。
一番初めに、faviconとog_imageから取り組んだ。
これは、７日のToday I Learnedの通りである。
まず、見本の成果物でfaviconもしくはog_imageの削除を実行すると
admin/site/attachments/(id)
というパスが送られる。
deleteでは無いのだ。
これは、どういうことかというと、destroyだけ、コントローラーを切り分けているということだ。
実装するコントローラは
```
admin/site/attachments_controller.rb

class Admin::Site::AttachmentsController < ApplicationController
  def destroy
    authorize(current_site)
    image = ActiveStorage::Attachment.find(params[:id])
    image.purge
    redirect_to edit_admin_site_path
  end
end
```
である。
注目すべきは、class名であり「Adminの中にSiteがあり、Siteの中にAttachmentsController」があるという意味らしい。
::はディレクトリの階層のようなもので、このようなクラス名であれば
app/controllers/admin/site/attachments_controller.rb
となる。
次に注目すべきは、ActiveStorage::Attachment.find(params[:id])である。
普通はActiveRecordで呼び出す発想をするが、このアプリにはActiveStorageを適用しているので、このような呼び出し方ができる。
params[:id]はActiveStorage_Attachmentの主キーである。
なので、typeとidを区別できるという仕組みである。
ちなみに、authorize(current_site)で権限の認証をしていることから
```
  def destroy?
    user.admin?
  end
```
の追記が必要である。

先程のclass Admin::Site::AttachmentsControllerと定義すれば、ルーティングもこの構造に対応する必要があり、ルーティングはネストすることとなる。
```
    resource :site, only: %i[edit update] do
      resources :attachments, controller: 'site/attachments', only: %i[destroy]
    end
```
do をつけてインデントを下げてネストさせる。
これにより、admin/site/attachments/(id)のルートが生成される。
なお、ここで気を付ける点は、resource(単数系)ではなく、resources(複数形)にする必要がある。
そうしなければ、パスにidをつけることができない。
viewsの削除ボタンは、このようになる
```
        = link_to '削除', admin_site_attachment_path(@site.favicon.id),
          method: :delete, class: 'btn btn-danger'
        br
        br

        = link_to '削除', admin_site_attachment_path(@site.og_image.id),
          method: :delete, class: 'btn btn-danger'
        br
        br
```

続いて、maim_imageの実装である。
ActiveStorageのおかげで、columnを追加するのではなく、簡単に拡張することができる。
方法は、modelに
```
has_many_attached :main_images

validates :main_images, attachment: { purge: true, content_type: %r{\Aimage/(png|jpeg)\Z}, maximum: 524_288_000 }
```
を追記するだけでいい。
ストロングパラメーターも追加しておかなければならない。
```
  def site_params
    params.require(:site).permit(:name, :subtitle, :description, :favicon, :og_image, main_images: [])
  end
```
main_imagesの実装で一番難しいのは、カスタムバリデータである。
画像が単数の場合と、複数の場合で条件を分岐させなければならない。
```
has_error = false

    if options[:maximum]
      if value.is_a?(ActiveStorage::Attached::Many)
        # 画像が複数枚投稿された場合
        value.each do |v|
          unless validate_maximum(record, attribute, v)
            has_error = true
            break
          end
        end
      else
        # 画像が1枚投稿された場合
        has_error = true unless validate_maximum(record, attribute, value)
      end
    end

    if options[:content_type]
      if value.is_a?(ActiveStorage::Attached::Many)
        # 画像が複数枚投稿された場合
        value.each do |v|
          unless validate_content_type(record, attribute, v)
            has_error = true
            break
          end
        end
      else
        # 画像が1枚投稿された場合
        has_error = true unless validate_content_type(record, attribute, value)
      end
    end
```
ここは、一度で理解しようとせず、何度も技術記事などを読み、理解していく必要があると感じた。
そして、main_imageのviewはこのようになる
```
      = f.input :main_images, as: :file, input_html: {multiple: true}, hint: 'JPEG/PNG (1200x400)'

      - if @site.main_images.attached?
        .main_images_box
          - @site.main_images.each do |main_image|
            .main_image
              = image_tag main_image.variant(resize:'300x100').processed
              = link_to '削除', admin_site_attachment_path(main_image.id),
                method: :delete, class: 'btn btn-danger'
```

残るはswiperの実装であるが、ここは、まだよく理解していない。
そもそも、そこまで時間をかけて復習する必要性が感じられない。
将来、必ずしもswiperを使う訳ではないし、だたのドキュメントの一つだ。
Gemにしても、ドキュメントにしても、現役エンジニアが全ての実装方法を覚えている、知っている訳ではないはずだ。

本日は、ActiveRecordとSQLの応用編に取り組んだ。
予想した通り、SQLに関しては、ほとんど忘れていて、手が動かなかった。
まず、できることからと思い SHOW TABLES;　でテーブルの一覧を表示し、DESCRIBEでテーブルが持つcolumnを表示させたりした。
とりあえず、全て表示させて、絞り込むという方針を立てた。
SELECT *
FROM staff;
とすると、実行出来ずに、訳がわからないエラーとなった。
その理由は、バイナリデータ（画像、音声、動画など）を持つcolumnがあり、テキストで出力することができないからである。
バイナリデータのデータ型は
SELECT * は便利であるが、常に適切とは限らない。
データ型にblob型があれば、エラーとなるので、常にデータ型をよく確認する必要がある。
また、ActiveStorageについて学んだことは、定義しているアソシエーションによって、テーブルをjoinする際、複数形なのか単数系になるのかである。
```
Film　has_many :inventories
Inventory　belongs_to :film
```
このようなアソシエーションであれば

Inventoryからみたfilmは１の関係なのでInventory.joins(:film)となる。

FilmからみたInventoryは多の関係なので、Film.joins(:inventories)となる。

今日は、１０問中、２問しか解けなかったので、明日、続きをする。
また、そろそろ、１１月のアウトプット会の資料作りに着手したい。
朝と昼は、カリキュラムを進めて、夜は、資料作りをしようと思う。
