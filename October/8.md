本日は、Rails課題９に取り組んだ。
main_imageを追加する機能から取り組んだ。
まず、siteのmodelに
```
has_many_attached :main_images
```
フォームはこのように記述する
```
= f.input :main_images, as: :file, hint: 'JPEG/PNG (1200x630)', input_html: { multiple: true }
```
multiple: trueにする場合、バリデーションはhas_many_attachedにしなければならない。

その後、
```
- if @site.main_images.attached?
        - @site.main_images.each do |image|
          = image_tag image.variant(resize: "200x105"), class: 'main_images'
# active storageでは、variantメソッドによってファイルのサイズを指定できる
          = link_to admin_site_attachment_path(image.id), method: :delete
            i.fa.fa-trash
            | 削除
```
と記述する（ほぼ、記事に書いている通りに実装した）

このまま動作確認をすると、バリデーションエラーとなる。
アプリは、カスタムバリデータを使用しており、バリデーションチェックを複数画像の場合と、単数画像の場合で分ける必要がある。
```
class AttachmentValidator < ActiveModel::EachValidator
  include ActiveSupport::NumberHelper

  def validate_each(record, attribute, value)
    return if value.blank? || !value.attached?

    has_error = false
# valueが空の場合はエラーを返さずにそこで処理を終わらせる

    if options[:maximum]
# Modelのバリデーションでmaximumオプション指定されているときは下の処理を行う
      if value.is_a?(ActiveStorage::Attached::Many)
# is_a?メソッドは、オブジェクトの中身(value)が引数で渡されたもの(ActiveStorage::Attached::Many)であればtrueを、それ以外ならばfalseを返す。

        value.each do |one_value|
# 今回はvalueが複数画像の場合はone_valueごとにバリデーションをかけている

          unless validate_maximum(record, attribute, one_value)
            has_error = true
# validate_maximumがfalseの場合はhas_error = trueを返す 
          end
        end
      else
        has_error = true unless validate_maximum(record, attribute, value)
#こちらはvalueが複数画像ではなかった場合の処理

    end

    if options[:content_type]
      if value.is_a?(ActiveStorage::Attached::Many)
        value.each do |one_value|
          unless validate_content_type(record, attribute, one_value)
            has_error = true
          end
        end
      else
        has_error = true unless validate_content_type(record, attribute, value)
    end

    record.send(attribute).purge if options[:purge] && has_error
# バリデーションでpurge: trueが指定されており、尚且つ上の分岐でhas_error = trueとなっている時に送られてきた画像データをpurgeする。

  end

  private

  def validate_maximum(record, attribute, value)
    if value.byte_size > options[:maximum]
# options[:maximum]で、Modelのバリデーションで定義されたmaximumのハッシュの値を取得できる。

      record.errors[attribute] << (options[:message] || "は#{number_to_human_size(options[:maximum])}以下にしてください")
      false
    else
      true
    end
  end

  def validate_content_type(record, attribute, value)
    if value.content_type.match?(options[:content_type])
# こちらも同じくoption[:content_type]で、Modelのバリデーションで定義されたcontent_typeのハッシュの値（つまり指定されたファイル形式）をとってこれる。そしてmatch?メソッドでvalueのファイル形式と一致しているかチェック。

      true
    else
      record.errors[attribute] << (options[:message] || 'は対応できないファイル形式です')
      false
    end
  end
end
```
カスタムバリデーションは、ほぼ理解していないので、何度も目を通したい。

次に、Swiperの実装であるが、なかなかフロント側の実装はうまくいかない。
明日中に解決して、LGTMをもらい、明後日は、復習にしたい。