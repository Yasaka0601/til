中間試験Rails課題３
サインアップGithubのname検証機能
フォームオブジェクトに
  def check_github_name
    uri = URI.parse("https://github.com/#{name}")
    response = Net::HTTP.get_response(uri)
    unless response.code == "200"
      errors.add(:name, "GitHub does not exist")
    end
  end
と記述。
Githubにnameが存在しない場合のフラッシュメッセージ表示のロジックがわからなかった。
include?メソッドを使うことでエラー内容に応じてフラッシュメッセージを表示させるロジックを作成した。
include?は特定の要素が配列、文字列、ハッシュに含まれているかをtrueかfalseで返すメソッドである。

def create
  @sign_up_form = SignUpForm.new(sign_up_form_params)

  if @sign_up_form.save
    session[:user_id] = @sign_up_form.user.id
    redirect_to posts_path, success: 'サインアップしました'
  else
    if @sign_up_form.errors[:name].include?("GitHubに存在するユーザー名しか登録できません")
      flash.now[:danger] = "GitHubに存在しないユーザー名です"
    else
      flash.now[:danger] = "サインアップに失敗しました"
    end

    render :new
  end
end

調査結果を基に、コーディングを行った。
しかし、バグが表示されないものの、想定している動作とは異なる動作をした。（バグを表示してくれた方がありがたい）
🔴想定している通りの動作にならない。
不具合の内容。
Github名に関わらず、全てのnameに対してサインアップができなくなった。（エラーの表示は出ていない）

チェック項目
🔶app/forms/sign_up_form.rb に追加した記述（フォームオブジェクト）

require 'net/http'
require 'uri'
これで、外部ライブラリを追加。

attr_accessor :name
外部からnameを受け取る、かつ、変更を可能にする。

validate :check_github_name
カスタムバリデーション。
バリデーションチェックにcheck_github_nameを追加。

private
  def check_github_name
    uri = URI.parse("https://github.com/#{name}")
    response = Net::HTTP.get_response(uri)
    unless response.code == "200"
      errors.add(:name, "GitHub does not exist")
    end
  end
バリデーションチェックに追加したメソッド。

ここまでの記述によって、フォームオブジェクト内に記載の
  def save
    return false if invalid? #バリデーションエラーがあったら、保存せずにfalseを返す。

    ActiveRecord::Base.transaction do #トランザクション開始。do...end 内のブロックが全て成功した時のみ保存。途中でエラーがあれば全てキャンセル。
      user.save! #保存に失敗したら、例外（エラー）を強制的に出す。userは下に書いているメソッドで定義
      Profile.create!(name: name, user: user) #プロフィールにも保存。!で破壊的メソッド
    end
  rescue StandardError #save!,create!でエラーが出た場合の処理。rescueがなければアプリがエラーとなる。
    false # falseを返して登録失敗
  end
のinvalid?によってバリデーションチェックが行われる。

🔶デバック結果
１　カスタムバリデーションのメソッド
  　def check_github_name
    　uri = URI.parse("https://github.com/#{name}")
    　response = Net::HTTP.get_response(uri)
    　unless response.code == "200"
     　 errors.add(:name, "GitHub does not exist")
      　byebug
    　end
  　end

　byebugをこの位置に記述するも、処理が止まらない。
　つまり、このメソッドはサインアップ処理で呼ばれていないことが判明した。

２　saveメソッド
　　  def save
    return false if invalid?

    ActiveRecord::Base.transaction do
      user.save!
      Profile.create!(name: name, user: user)
    end
  rescue StandardError
    byebug
    false
  end
この位置にbyebugを記載し、デバックをしたところ
(byebug) @sign_up_form.errors.full_messages
*** NoMethodError Exception: undefined method `errors' for nil:NilClass
nil
これは、nilに対してerrorsを呼んでいると言う意味。
つまり、インスタンス変数@sign_up_formが生成されていないと推測。

　３　users_controllerのcreateアクション（インスタンス変数が生成されていないかの確認。）
　　　
　　　[3, 12] in /app/app/controllers/users_controller.rb
    3:     @sign_up_form = SignUpForm.new
    4:   end
    5:
    6:   def create
    7:     byebug
=>  8:     @sign_up_form = SignUpForm.new(sign_up_form_params)
    9:     if @sign_up_form.save
   10:       session[:user_id] = @sign_up_form.user.id
   11:       redirect_to posts_path, success: 'サインアップしました'
   12:     else
　　　byebugをこの位置に記載。
　　　すると、
　　　(byebug) @sign_up_form.nil?
　　　　true
　　　これにより、インスタンス変数@sign_up_formが生成されていないことが確定。
　　　続けて、paramsに値が格納されていないことによりインスタンス変数が生成されていないと推測。
　　　しかし、params内を確認すると
　　　(byebug) sign_up_form_params
　　　#<ActionController::Parameters {
     "email"=>"test4.@com",
     "password"=>"00000",
     "password_confirmation"=>"00000",
     "name"=>"テストユーザー"}
      permitted: true>
      と値が返ってきた為、フォームオブジェクトの不具合と推測。

🔶　原因判明
　　app/forms/sign_up_form.rb
　　フォームオブジェクトのコードを確認すると
　　  attribute :name, :string
　　の記述と
　　　attr_accessor :name
   の記述があった。

   以下,ChatGPTによる解説
   宣言　　　　　　　　　　　　　　　
　　attr_accessor :name
　　目的　
　　単純に @name というインスタンス変数の getter/setter を自前で用意
　　仕組み
　　@name = 値 に直接代入

　　宣言
　　attribute :name, :string
　　目的
　　ActiveModel の内部で、型変換やデフォルト値、changed? チェックなどをサポートする特殊な属性として登録
　　仕組み
　　getter/setter を DSL で定義＋attributes_hash に保存
　
　　attribute :name, :string によって ActiveModel が name に「型付き属性」としてのロジックを持たせようとする。

　　が、その後に attr_accessor :name を書いてしまうと：
	•	Ruby の文法上、後に書いた attr_accessor :name が勝つ
	•	ActiveModel が定義した name の getter/setter が 無効化される
	•	結果的に attributes[:name] のような内部状態に name が存在してても、form.name では読めなくなる
	•	nil を返してくる

　不具合があっても、Railsは表示させてしまうことがある。
　そうなると、デバックに苦労する。
　本日は、講師が休みなので、レビューは明日となる。
　明日は用事があるので、どれだけ学習時間を確保できるのか不明である。
　LGTMであれば、アプリ開発に着手しようと思う。
　RUNTEQの応用編と、アプリ開発を並行して進めようと思う。