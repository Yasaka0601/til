本日も、Rails応用課題４に取り組んだ。
まず、昨日の復習から行った。
ポリモーフィック関連のことである。
復習したが、正直、まだ完璧に理解していない。
しかも、テーブル構造関連について、調査を進めると、STIという概念まで登場した。
STI（Single Table Inheritance）シングル　テーブル　インヘリタンス
Inheritanceとは、直訳して「相続」という意味らしい。
STIとは、１つのテーブルを、複数のモデルで共有する仕組みのことらしい。
例えばusersテーブルに「生徒」と「先生」を同じテーブルに保存するとする。
「生徒」「先生」の区別は、type columnで行う。
するとテーブルにはこのように保存される。
id　　　　name　　　type
1　　　　　太郎　　　Student
2　　　　　花子　　　Teacher
同じテーブルに記録するが、Studentモデル / Teacherモデルとして扱うことができる。

しかし、ポリモーフィズムとSTIは、とても似ていると感じている。

ポリモーフィズムは、あるテーブルがいろんなモデルを対応付けるという仕組みである。
例えば、コメントを「記事」や「画像」につけたいとする。
その場合、アソシエーションはこのように定義する
```
class Comment < ApplicationRecord
  belongs_to :commentable, polymorphic: true
end

class Article < ApplicationRecord
  has_many :comments, as: :commentable
end

class Photo < ApplicationRecord
  has_many :comments, as: :commentable
end
```
そして、テーブルにはこのように保存される。
id　　　　　body　　　　commentable_type　　　　commentable_id
1　　　　　いい記事！　　　Article　　　　　　　　　1
2　　　　　かわいい　　　　Photo　　　　　　　　　　5

ポリモーフィズムの方が、仕組みとしては複雑かもしれない。
簡単にいうと、中間テーブルに色々対応づけているということだ。
（合同アウトプット会に登壇するなら、これをネタにしたい。理解が深まる）

また、publishes_controller.rbのupdateアクションを作成した。（ロボらんてくんに助けてもらいながら）
```
def update
  @article.published_at = Time.current unless @article.published_at?

  if @article.published_at <= Time.current
    @article.state = :published
  else
    @article.state = :publish_wait
  end

  if @article.valid?
    Article.transaction do
      @article.body = @article.build_body(self)
      @article.save!
    end


    if @article.published?
      flash[:notice] = '記事を公開しました'
    else
      flash[:notice] = '記事を公開待ちにしました'
    end
    redirect_to edit_admin_article_path(@article.uuid)
  else
    flash.now[:alert] = 'エラーがあります。確認してください。'
    @article.state = @article.state_was if @article.state_changed?
    render 'admin/articles/edit'
  end
end
```
いきなり完成したコードを貼ったが、ここまで作成するに至った経緯を記述すると長くなるので、コードの解釈のみ記載する
```
def update
  #article.published_atがnilの場合の処理。現在の時刻を格納している。
  @article.published_at = Time.current unless @article.published_at?

  #article.published_atと現在時刻を比較。（公開予定日時 ＜ 現在時刻）
  if @article.published_at <= Time.current
    #公開予定日時が過去の場合、published（公開）にしている。
    @article.state = :published
  else
    #公開予定日時が未来の場合、publish_wait（公開予定）にしている。
    @article.state = :publish_wait
  end

  if @article.valid?　#バリデーションチェックをしている。
  　#バリデーションチェックに合格すれば、トランザクション開始。
    Article.transaction do
    　#build_bodyメソッドによって、bodyを生成。
      @article.body = @article.build_body(self)
      @article.save!
    end

    #articleがpublishedであるのかを判定している。
    if @article.published?
    　#trueの場合、「記事を公開しました」というフラッシュメッセージを表示
      flash[:notice] = '記事を公開しました'
    else
    　#falseの場合、「記事を公開待ちにしました」というフラッシュメッセージを表示
      flash[:notice] = '記事を公開待ちにしました'
    end
    redirect_to edit_admin_article_path(@article.uuid)
  else
    flash.now[:alert] = 'エラーがあります。確認してください。'
    #これは「Dirty Tracking」という機能。
    @article.state = @article.state_was if @article.state_changed?
    render 'admin/articles/edit'
  end
end
```

Dirty Tracking（ダーティトラッキング）について。
モデルのオブジェクトのcolumnが、DBに保存される前と比べて変更されたかどうかを追跡する機能のこと。
```
@article.state = @article.state_was if @article.state_changed?
```
if @article.state_changed?の「state_changed?」メソッドでstateに変更があったのか判定している。
trueであれば、@article.state_wasを@article.stateに代入。
「state_was」は、変更前の値を取得している。

明日は、rakeタスクや、wheneverについて実装方法を調査し、できれば実装までしたい。
欲を言えば、明日で課題４を終わらせたい。
明日の目標は、課題４を終わらせることにしよう。